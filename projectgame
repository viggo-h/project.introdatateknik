import pygame
import sys
pygame.init()

# Skapa fönstret
screen = pygame.display.set_mode((800, 600))
pygame.display.set_caption("Pygame")

# Bakgrundsbild
background_image = pygame.image.load("background.png")
background_image = pygame.transform.scale(background_image, (800, 600))  

#Bilder för hinder
brick_wall = pygame.image.load("brick_wall.jpg")
brick_wall = pygame.transform.scale(brick_wall, (100, 40))
stone = pygame.image.load("stone.PNG")
stone = pygame.transform.scale(stone, (10,10))

#Attribut för boss
boss = pygame.image.load("boss.PNG")
boss = pygame.transform.scale(boss, (300,300))


# Färger 
black = (0, 0, 0)
white = (255, 255, 255)
blue=(0,0,255)
red = (255, 0, 0)
silver =(192, 192, 192)
yellow =(255,223,0)

# Huvudkaraktär position 
circle_x, circle_y = 40, 300
circle_radius = 40
circle_speed_x = 10
circle_speed_y = 0
jump_strength = -10
gravity = 0.5
on_ground = False
doublejump = False  

#Liv och skada
hearts = 3
tagen_skada = False
kollision = False

fiende_x, fiende_y = 300, 520
fiende_storlek = 80
fiende_speed_x = -5 
fiende_image = pygame.image.load("Thwomp.gif")
fiende_image = pygame.transform.scale(fiende_image, (80, 80))  

#vinna grejer
cube_x, cube_y = 720, 520
cube_size = 60  
cube_image = pygame.image.load("goldapple.gif")
cube_image = pygame.transform.scale(cube_image, (cube_size, cube_size))  

 
# Text
font = pygame.font.Font(None, 74)
small_font = pygame.font.Font(None, 36)

level = 1  # Level
level_start = False
startmenu = True
gameover = False
onplatform = False


def show_start_menu(): #startskärm
    screen.fill(black)
    title_text = font.render("Welcome to the Game!", True, white)
    start_text = small_font.render("Press enter to begin", True, white)
    screen.blit(title_text, (800 // 2 - title_text.get_width() // 2, 200))
    screen.blit(start_text, (800 // 2 - start_text.get_width() // 2, 300))  
    pygame.display.flip()

def show_gameover(): #game over skärm
    screen.fill(black)
    gameover_text = font.render("Game Over!", True, red)
    restart_text = small_font.render("Press enter to try again", True, white)
    screen.blit(gameover_text, (800 // 2 - gameover_text.get_width() // 2, 250))
    screen.blit(restart_text, (800 // 2 - restart_text.get_width() // 2, 350))
    pygame.display.flip()

def environment(level):#level system
    title_text = font.render(f"Level {level}", True, white)
    screen.blit(title_text, (10, 30))


def lives(hearts):   #Life counter and damage calculater
        life_text = small_font.render(f"Lives {hearts}", True, white)
        screen.blit(life_text, (700,30))

# Huvudloop
while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()
        elif startmenu and event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN: #startmeny spelet startar vid enter
            startmenu = False
        elif gameover and event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN: #gameover spelet startar om vid enter
            if event.key == pygame.K_RETURN: #reset spelet
                circle_x, circle_y = 40, 300
                fiende_x, fiende_y = 400, 530
                fiende_speed_x = 5
                level = 1
                hearts = 3
                gameover = False
            elif event.key == pygame.K_RETURN:
                pygame.quit()
                sys.exit()
    if startmenu:
        show_start_menu()
        continue
    elif gameover:
        level_start = False
        show_gameover()
        continue  

    # Tangenttryckningar
    keys = pygame.key.get_pressed()

    #x-led rörelse
    if keys[pygame.K_LEFT]:
        circle_x -= circle_speed_x
    if keys[pygame.K_RIGHT]:
        circle_x += circle_speed_x

    # Hopp och dubbelhopp
    if keys[pygame.K_UP] and on_ground:
        circle_y -= 5
        circle_speed_y = jump_strength
        on_ground = False
        doublejump = True
    elif keys[pygame.K_UP] and doublejump and circle_y < 500:
        circle_speed_y = jump_strength
        doublejump = False
        
    # snabbt ner
    if keys[pygame.K_DOWN] and on_ground == False and onplatform== False:
        gravity *= 1.25
        damage = 2
    else:
        gravity = 0.5
    
    # Gravitation och vertikal rörelse
    if onplatform == False:
        circle_speed_y += gravity
        circle_y += circle_speed_y

    # Begränsar cirklerns rörelse
    circle_x = max(circle_radius, min(800 - circle_radius, circle_x))
    if circle_y >= 600 - circle_radius: #om cirklen är innanför
        circle_y = 600 - circle_radius
        circle_speed_y = 0
        on_ground = True
        gravity = 0.5
        doublejump = False
        
    # Uppdatera level 
    if level == 1 and circle_x == 760 and circle_y == 560: ##level 1
        circle_x = 0
        circle_y = 560
        fiende_x = 150
        fiende_y = 520
        level += 1
    
    if level == 2:
        fiende_speed_x = 10

    # Fiende rörelse i x led
    
    fiende_x += fiende_speed_x
    if level == 1 and fiende_x >= 750 or fiende_x <= 0:
        fiende_speed_x *= -1 
    if level == 2 and fiende_x >= 850:
        fiende_x = -50
        fiende_speed_x = 15
    

    #Uppdatera skärmen
    screen.blit(background_image, (0, 0))

    if gravity == 0.5:
        pygame.draw.circle(screen, black, (int(circle_x), int(circle_y)), circle_radius)
        if keys[pygame.K_LEFT] or keys[pygame.K_RIGHT]:
            pygame.draw.circle(screen, blue, (int(circle_x), int(circle_y)), int(circle_radius * 0.8))
    
    else: #extra efffekter om man gör attack ner
        pygame.draw.line(screen,black, (int(circle_x),int(circle_y)), (int(circle_x),int(circle_y-100)) ,8)
        pygame.draw.line(screen,black, (int(circle_x-20),int(circle_y)), (int(circle_x-30),int(circle_y-100)) ,8)
        pygame.draw.line(screen,black, (int(circle_x+20),int(circle_y)), (int(circle_x+30),int(circle_y-100)) ,8)
        pygame.draw.circle(screen, red, (int(circle_x), int(circle_y)), circle_radius)
    #fiende 
    screen.blit(fiende_image,(fiende_x,fiende_y))
    #level
    
    environment(level)
    #Life counter
    lives(hearts)   
    
    if level == 1: #level 1 goal
        cube_x, cube_y = 735, 535
        screen.blit(cube_image,(cube_x,cube_y))

##Hinder

    #Skapar ett hinder och ger den en hitbox
    obstacles = []
    if level == 1: #level 1 hinder
        obstacle1 = pygame.Rect(100, 450, 200, 40)
        obstacle2 = pygame.Rect(400, 350, 70, 250)
        obstacles =  [obstacle1, obstacle2]
        for obstacle in obstacles:
            for x in range(obstacle.x, obstacle.x + obstacle.width, brick_wall.get_width()):
                for y in range(obstacle.y, obstacle.y + obstacle.height, brick_wall.get_height()):
                    screen.blit(brick_wall, (x, y))     
        #Kontrollerar kontakt och skada med fienden
        fiende_kollision = (circle_x + 30 >= fiende_x and circle_x - 30 <= fiende_x + fiende_storlek and circle_y+circle_radius >= 560 )
        if fiende_kollision and not on_ground:
            fiende_x = -100
            fiende_y = -100
            fiende_speed_x = 0
            tagen_skada = True
        if fiende_kollision and not tagen_skada:       
            fiende_speed_x *= -1
            hearts -= 1
            tagen_skada = True
            if hearts == 0:
                gameover = True  
        if not (fiende_kollision):
                tagen_skada = False 
    
    
    #Level 2 saker
    if level ==2 and not level_start: #Ge karatären en specifik startpunkt för map-building
        circle_x, circle_y = 100, 410
        fiende_x, fiende_y = 720, 530
        level_start = True
    if level == 2:
        spik_x, spik_y, spik_x_storlek = 400, 160, 20
        spik_NHX,spik_NHY,spik_NHsize = 745,420,30
        spik_gropX, spik_gropY,spik_gropSize = 440, 250, 150
        spik_HangX,spik_HangY,spik_HangSize = 230, 270, 70
        ob1 = pygame.Rect(0, 450, 200, 20)     #Botten man landar på
        ob2 = pygame.Rect(200, 90, 40, 380)    #Högra väggen där man startar
        ob3 = pygame.Rect(85, 345, 115, 20)    #Den lägre av de högra platformarna av hoppusslet i starten
        ob4 = pygame.Rect(0, 245, 100, 20)     #Den vänstra av platforma av hoppusslet i starten
        ob5 = pygame.Rect(85, 145, 115, 20)    #Den högre av de högra platformarna av hoppusslet i starten
        ob6 = pygame.Rect(0, 0, 800, 1)        #Takblockerare så att man inte kan hoppa ur skärmen
        ob7 = pygame.Rect(210, 240, 230, 20)   #Platformen under takspiken
        ob8 = pygame.Rect(620, 240, 90, 20)    #Platformen man hoppar till från under spiken
        ob9 = pygame.Rect(700, 90, 20, 170)    #Väggen till droppet uppe till höger
        ob10 = pygame.Rect(600, 120, 20, 20)   #Platformen bredvid takspiken
        ob11 = pygame.Rect(350, 500, 450, 20)  #Platformen man väntar på inför slutspurten
        ob12 = pygame.Rect(580, 0, 20, 140)    #Väggen mot takspikens högra sida
        ob13 = pygame.Rect(420, 260, 20, 80)   #Väggen till vänster om undre spiken
        ob14 = pygame.Rect(420, 340, 205, 20)  #Platformen under den grop spikarna
        ob15 = pygame.Rect(620, 260, 20, 100)  #Väggen till höger om den undre spiken
        obstacles = [ob1,ob2,ob3,ob4,ob5,ob6,ob7,ob8,ob9,ob10,ob11,ob12,ob13,ob14,ob15]
        #Kontakt och skada med spikar och fienden för level två
        fiende_kollision = (circle_x + 30 >= fiende_x and circle_x - 30 <= fiende_x + fiende_storlek and circle_y+circle_radius >= 560 )   
        spik_kollision_NH = (circle_x + 30 >= spik_NHX and circle_x -30 <= spik_NHX + spik_NHsize and circle_y >= spik_NHY + 20 and circle_y <= spik_NHY - 20)
        spik_kollision = (circle_x + 30 >= spik_x and circle_x -30 <= spik_x + spik_x_storlek and circle_y <= spik_y + 20)
        spik_kollision_grop = (circle_x + 30 >= spik_gropX and circle_x -30 <= spik_gropX + spik_gropSize and circle_y <= spik_gropY + 5 and circle_y >= spik_gropY -5)
        if kollision == False:   
            if fiende_kollision and not tagen_skada:       
                fiende_speed_x *= -1
                hearts -= 1
                circle_x, circle_y = 100, 410
                tagen_skada = True
                kollision = True
                if hearts == 0:
                    gameover = True  
            if spik_kollision_NH and not tagen_skada:    
                hearts-=1   
                circle_x, circle_y = 100, 410
                tagen_skada = True 
                kollision = True
                if hearts == 0:
                    gameover = True
            if spik_kollision and not tagen_skada:    
                hearts-=1   
                circle_x, circle_y = 100, 410
                tagen_skada = True 
                kollision = True
                if hearts == 0:
                    gameover = True     
            if spik_kollision_grop and not tagen_skada: 
                hearts-=1
                circle_x, circle_y = 100, 410
                tagen_skada = True
                kollision = True
                if hearts == 0:
                    gameover = True   
        if not (fiende_kollision or (spik_kollision_NH or (spik_kollision or spik_kollision_grop))):
            tagen_skada = False 
            kollision = False
        pygame.draw.polygon(screen, (red), ((740,500), (800,500), (770,415)))  #Spiken nere i höger
        pygame.draw.polygon(screen, (red), ((440,340), (500,340), (470,270)))  #Vänstra gropspiken
        pygame.draw.polygon(screen, (red), ((500,340), (560,340), (530,270)))  #mittersta gropspiken
        pygame.draw.polygon(screen, (red), ((560,340), (620,340), (590,270)))  #Högra gropspiken
        pygame.draw.polygon(screen, (red), ((235,260), (280,260), (255,310)))  #Hängade spiken i slutet
        pygame.draw.polygon(screen, (red), ((430,0), (370,0), (400,160)))      #Takspiken

        for obstacle in obstacles:
            for x in range(obstacle.x, obstacle.x + obstacle.width, stone.get_width()):
                for y in range(obstacle.y, obstacle.y + obstacle.height, stone.get_height()):
                    screen.blit(stone, (x, y))

    
    
    
    
    #Kollision
    circle_rect = pygame.Rect(circle_x - circle_radius, circle_y - circle_radius, circle_radius * 2, circle_radius * 2)
    
    onplatform = False
    
    for obstacle in obstacles: #ger möjdlighet med olika hinder varje nivå
        if circle_rect.colliderect(obstacle):
            
            # över platformen
            if circle_y + circle_radius >= obstacle.top and circle_y <= obstacle.top:
                circle_speed_y = 0
                onplatform = True
                on_ground = True
                doublejump = True
                if circle_y + circle_radius > obstacle.top + 5 and circle_y < obstacle.top +5: #temporärt fixar bugg med att man hamnar i platformen
                    circle_y -= 10
                
            # vänster om platform
            elif circle_x + circle_radius > obstacle.left and circle_x < obstacle.left:
                circle_x = obstacle.left - circle_radius   
            #höger om platform
            elif circle_x - circle_radius < obstacle.right and circle_x > obstacle.right:
                circle_x = obstacle.right + circle_radius
            #under
            elif circle_y - circle_radius < obstacle.bottom and circle_y > obstacle.bottom:
                circle_y = obstacle.bottom + circle_radius
                circle_speed_y = max(circle_speed_y, 5)  
        if not onplatform:
            onplatform = False

    

    pygame.display.flip()
    pygame.time.delay(25)
